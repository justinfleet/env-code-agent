/**
 * Express Server Code Generator
 * Generates Fleet-compliant Express server from API schema
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import type { APIEndpoint, DatabaseSchema, GenerationResult } from '../types.js';
import type { RequestExample } from '../explorer/request-executor.js';

export class ServerGenerator {
  private outputDir: string;
  private filesGenerated: string[] = [];

  constructor(outputDir: string) {
    this.outputDir = outputDir;
  }

  /**
   * Generate complete server code
   */
  async generate(
    endpoints: APIEndpoint[],
    examples: RequestExample[],
    schema: DatabaseSchema
  ): Promise<GenerationResult> {
    console.log(`ðŸ—ï¸  Generating server code in ${this.outputDir}...`);

    // Create directory structure
    this.createDirectoryStructure();

    // Generate server files
    this.generatePackageJson();
    this.generateTsConfig();
    this.generateEnvExample();
    this.generateIndexTs(endpoints);
    this.generateDatabaseTs();
    this.generateConfigTs();
    this.generateRoutes(endpoints, examples);

    console.log(`âœ… Generated ${this.filesGenerated.length} server files`);

    return {
      outputPath: this.outputDir,
      filesGenerated: this.filesGenerated,
      schema,
      endpoints
    };
  }

  /**
   * Create directory structure
   */
  private createDirectoryStructure(): void {
    const dirs = [
      this.outputDir,
      join(this.outputDir, 'src'),
      join(this.outputDir, 'src/routes'),
      join(this.outputDir, 'data')
    ];

    for (const dir of dirs) {
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
    }
  }

  /**
   * Generate package.json
   */
  private generatePackageJson(): void {
    const pkg = {
      name: 'cloned-api-server',
      version: '1.0.0',
      description: 'Auto-generated API server from env-code-agent',
      type: 'module',
      main: 'dist/index.js',
      scripts: {
        dev: 'tsx watch src/index.ts',
        build: 'tsc',
        start: 'node dist/index.js'
      },
      dependencies: {
        'better-sqlite3': '^12.4.1',
        compression: '^1.8.1',
        cors: '^2.8.5',
        dotenv: '^17.2.3',
        express: '^4.21.1',
        helmet: '^8.1.0'
      },
      devDependencies: {
        '@types/better-sqlite3': '^7.6.13',
        '@types/compression': '^1.8.1',
        '@types/cors': '^2.8.19',
        '@types/express': '^4.17.21',
        '@types/node': '^20.19.4',
        tsx: '^4.20.6',
        typescript: '^5.9.3'
      },
      engines: {
        node: '^20.19.4',
        pnpm: '^9.15.1'
      },
      packageManager: 'pnpm@9.15.1'
    };

    this.writeFile('package.json', JSON.stringify(pkg, null, 2));
  }

  /**
   * Generate tsconfig.json
   */
  private generateTsConfig(): void {
    const tsconfig = {
      compilerOptions: {
        target: 'ES2022',
        module: 'ESNext',
        lib: ['ES2022'],
        moduleResolution: 'bundler',
        outDir: './dist',
        rootDir: './src',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist']
    };

    this.writeFile('tsconfig.json', JSON.stringify(tsconfig, null, 2));
  }

  /**
   * Generate .env.example
   */
  private generateEnvExample(): void {
    const env = `# Database configuration
DATABASE_PATH=./data
PORT=3000
NODE_ENV=development
`;
    this.writeFile('.env.example', env);
  }

  /**
   * Generate main index.ts
   */
  private generateIndexTs(endpoints: APIEndpoint[]): void {
    const code = `/**
 * Auto-generated Express server
 * Generated by env-code-agent
 */

import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import { config } from './config.js';
import { initDatabase } from './database.js';

// Import routes
${this.generateRouteImports(endpoints)}

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Initialize database
const db = initDatabase();

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Register routes
${this.generateRouteRegistrations(endpoints)}

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Not found' });
});

// Error handler
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err);
  res.status(500).json({ error: 'Internal server error' });
});

// Start server
const PORT = config.port;
app.listen(PORT, () => {
  console.log(\`ðŸš€ Server running on port \${PORT}\`);
  console.log(\`ðŸ“Š Database: \${config.databasePath}\`);
});

export { app, db };
`;

    this.writeFile('src/index.ts', code);
  }

  /**
   * Generate database.ts
   */
  private generateDatabaseTs(): void {
    const code = `/**
 * Database connection and initialization
 * Follows Fleet environment standards
 */

import Database from 'better-sqlite3';
import { existsSync, copyFileSync } from 'fs';
import { join, dirname } from 'path';
import { config } from './config.js';

export function initDatabase(): Database.Database {
  const dbPath = getDatabasePath();

  console.log(\`ðŸ“‚ Database path: \${dbPath}\`);

  // Copy seed.db to current.sqlite if it doesn't exist (Fleet standard)
  const seedPath = join(dirname(dbPath), 'seed.db');
  if (!existsSync(dbPath) && existsSync(seedPath)) {
    console.log(\`ðŸ“‹ Copying seed.db to current.sqlite\`);
    copyFileSync(seedPath, dbPath);
  }

  // Open database
  const db = new Database(dbPath);

  // Enable WAL mode and foreign keys (Fleet requirements)
  db.pragma('journal_mode = WAL');
  db.pragma('foreign_keys = ON');

  console.log(\`âœ… Database initialized\`);
  return db;
}

function getDatabasePath(): string {
  // Fleet standard: DATABASE_PATH > ENV_DB_DIR > ./data/current.sqlite
  if (config.databasePath) {
    return join(config.databasePath, 'current.sqlite');
  }

  if (process.env.ENV_DB_DIR) {
    return join(process.env.ENV_DB_DIR, 'current.sqlite');
  }

  return './data/current.sqlite';
}
`;

    this.writeFile('src/database.ts', code);
  }

  /**
   * Generate config.ts
   */
  private generateConfigTs(): void {
    const code = `/**
 * Configuration management
 */

import dotenv from 'dotenv';

dotenv.config();

export const config = {
  port: parseInt(process.env.PORT || '3000', 10),
  databasePath: process.env.DATABASE_PATH || './data',
  nodeEnv: process.env.NODE_ENV || 'development'
};
`;

    this.writeFile('src/config.ts', code);
  }

  /**
   * Generate route files
   */
  private generateRoutes(endpoints: APIEndpoint[], examples: RequestExample[]): void {
    // Group endpoints by base path
    const routeGroups = this.groupEndpointsByBasePath(endpoints);

    for (const [basePath, groupEndpoints] of routeGroups.entries()) {
      this.generateRouteFile(basePath, groupEndpoints, examples);
    }
  }

  /**
   * Group endpoints by their base path
   */
  private groupEndpointsByBasePath(endpoints: APIEndpoint[]): Map<string, APIEndpoint[]> {
    const groups = new Map<string, APIEndpoint[]>();

    for (const endpoint of endpoints) {
      const basePath = this.extractBasePath(endpoint.path);
      if (!groups.has(basePath)) {
        groups.set(basePath, []);
      }
      groups.get(basePath)!.push(endpoint);
    }

    return groups;
  }

  /**
   * Extract base path from full path
   */
  private extractBasePath(path: string): string {
    const parts = path.split('/').filter(p => p && !p.match(/^(api|v\d+)$/));
    return parts[0] || 'root';
  }

  /**
   * Generate a route file for a group of endpoints
   */
  private generateRouteFile(
    basePath: string,
    endpoints: APIEndpoint[],
    examples: RequestExample[]
  ): void {
    const routeName = basePath.replace(/[^a-zA-Z0-9]/g, '_');

    let code = `/**
 * Routes for ${basePath}
 * Auto-generated by env-code-agent
 */

import { Router } from 'express';
import type { Request, Response } from 'express';

const router = Router();

`;

    // Generate handler for each endpoint
    for (const endpoint of endpoints) {
      code += this.generateRouteHandler(endpoint, examples);
      code += '\n';
    }

    code += `\nexport default router;\n`;

    this.writeFile(`src/routes/${routeName}.ts`, code);
  }

  /**
   * Generate handler for a single endpoint
   */
  private generateRouteHandler(endpoint: APIEndpoint, examples: RequestExample[]): string {
    // Find example for this endpoint
    const example = examples.find(
      e => e.endpoint.path === endpoint.path && e.endpoint.method === endpoint.method
    );

    const path = this.convertPathToExpress(endpoint.path);
    const method = endpoint.method.toLowerCase();

    let handler = `// ${endpoint.method} ${endpoint.path}\n`;
    handler += `router.${method}('${path}', (req: Request, res: Response) => {\n`;

    if (example && example.response.body) {
      // Return example response as mock
      handler += `  // TODO: Implement actual logic - currently returning mock data\n`;
      handler += `  res.json(${JSON.stringify(example.response.body, null, 2)});\n`;
    } else {
      handler += `  // TODO: Implement handler\n`;
      handler += `  res.json({ message: 'Not implemented' });\n`;
    }

    handler += `});\n`;

    return handler;
  }

  /**
   * Convert path parameters to Express format
   */
  private convertPathToExpress(path: string): string {
    // Convert {id} or :id to :id (Express format)
    return path.replace(/\{([^}]+)\}/g, ':$1').replace(/^\/api/, '');
  }

  /**
   * Generate route imports
   */
  private generateRouteImports(endpoints: APIEndpoint[]): string {
    const routeGroups = this.groupEndpointsByBasePath(endpoints);
    let imports = '';

    for (const basePath of routeGroups.keys()) {
      const routeName = basePath.replace(/[^a-zA-Z0-9]/g, '_');
      imports += `import ${routeName}Routes from './routes/${routeName}.js';\n`;
    }

    return imports;
  }

  /**
   * Generate route registrations
   */
  private generateRouteRegistrations(endpoints: APIEndpoint[]): string {
    const routeGroups = this.groupEndpointsByBasePath(endpoints);
    let registrations = '';

    for (const [basePath, _] of routeGroups.entries()) {
      const routeName = basePath.replace(/[^a-zA-Z0-9]/g, '_');
      const mountPath = `/api/${basePath}`;
      registrations += `app.use('${mountPath}', ${routeName}Routes);\n`;
    }

    return registrations;
  }

  /**
   * Write file and track it
   */
  private writeFile(relativePath: string, content: string): void {
    const fullPath = join(this.outputDir, relativePath);
    writeFileSync(fullPath, content, 'utf-8');
    this.filesGenerated.push(relativePath);
    console.log(`  âœ“ Generated: ${relativePath}`);
  }
}
